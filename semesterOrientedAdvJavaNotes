        ADVANCE JAVA SEMESTER ORIENTED
UNIT-I Introduction JDBC: Introduction, JDBC Driver, DB Connectivity, Driver Manager, Connection, Statement, Result Set, Prepared 8 Hours Statement, Transaction Management, Stored Procedures. Servlet: Servlet Overview, Servlet API, Servlet Interface, Generic Servlet, HTTP Servlet, Servlet Life Cycle, Redirect requests to other resources, Session Tracking, Event and Listener.   

UNIT-II JSP JSP: Introduction, Overview, JSP Scriptlet Tag, JSP expression Tag, JSP declaration Tag, Life Cycle of JSP, JSP API, Implicit Objects: JSP request, JSP response, JSP config, JSP session, JSP Application, JSP Page Context; JSP Page, JSP Exception. 

UNIT-III Spring 5.0 Spring 5.0: Spring Core Introduction and Overview, Managing Beans, The Spring Container, The Factory Pattern, Dependency Injection (DI), Spring Managed Bean Lifecycle, Constructor Injection, Metadata/Configuration: Life Cycle Annotations, Java Configuration, XML Free configuration. 

UNIT-IV Spring MVC & Spring Boot Spring MVC: Introduction/Developing Web Application with Spring MVC, Advanced Techniques, Spring Controllers Spring Boot: Spring Boot Starters, CLI, Application Class, Logging, Auto Configuration Classes, Spring Boot dependencies, Spring data JPA introduction and Overview. 

UNIT-V JPA JPA: Introduction & overview of data persistence, Overview of ORM tools, Understanding JPA, Entities: 8 Hours Requirement for Entity Class, Persistent Fields and Properties, Primary keys in Entries, Entity Management, Querying Entities, Entities Relationships. 





UNIT 1 INTRODUCTION JDBC (java database connectivity)-----------------------------------------------------------
UNIT-I Introduction JDBC: 
Introduction, JDBC Driver, DB Connectivity, Driver Manager, Connection, Statement, Result Set, Prepared 8 Hours Statement, Transaction Management, Stored Procedures. Servlet: Servlet Overview, Servlet API, Servlet Interface, Generic Servlet, HTTP Servlet, Servlet Life Cycle, Redirect requests to other resources, Session Tracking, Event and Listener. 
introduction
definition:  :  :
jdbc(java database connectivity) is a java api that enables java applications to interact with relational database like mysql, oracle using SQL. It provides a standard interface for connecting to database, executing queries, and retrieving results, making java programs database-intependent.
JDBC components:  :  :
1. jdbc api: core interfaces and classes in the java.sql and javax.sql packages.
a.	Driver manager=manages database drivers and establishes connnecitons
b.	Connections=represents a database session
c.	Statement=executes sql queries
d.	resultSet=holds query results for processing
e.	preparedstatement=precompiled sql for secure, efficient queries.
2. jdbc drivers: database specific implementation of jdbc interfaces, provided by database vendors like connector/j
3. database: the relational database accessed via jdbc.
JDBC architecture:  :  :
1.client layer(a jdbc client is any java application or applet that connects to a server based database using jdbc api)
2.driver manager layer(the driver manager is a service of the jdbc api that manage the drivers and establishes a connection between a jdbc client and a database server.)
3.database server(a database server is a software program that provides database management functionality within a networked computing environment.)
The flow is like :
Application calls jdbc api-> the jdbc api delegates to the driver    ->driver communicates with the database, executes sql, and returns result via resultset.
[Java Application] --> [JDBC API] --> [JDBC Driver] --> [Database]
   (Your LMS code)      (java.sql)    (e.g., MySQL    (e.g., MySQL)
                                       Connector/J)
JDBC drivers:  :  :
jdbc drivers are software components that enables communication between the jdbc api and a specific database.
Four types of jdbc drivers:
Type 1: JDBC-ODBC Bridge Driver:
Uses ODBC (Open Database Connectivity) to connect to databases.
How It Works: Translates JDBC calls to ODBC, which then interacts with the database.
Pros: Works with any ODBC-compatible database.
Cons:
Requires ODBC setup on the client machine.
Poor performance due to multiple layers.
Not supported in modern Java (removed in Java 8+).
Use Case: Rarely used; not recommended for your LMS.
Type 2: Native-API Driver:
Uses database-specific native libraries (e.g., C/C++ code) to communicate.
How It Works: JDBC calls are converted to native database calls via a native library.
Pros: Faster than Type 1 due to direct native access.
Cons:
Requires native libraries, reducing portability.
Platform-dependent (e.g., Windows DLLs).
Use Case: Legacy systems; not ideal for your cross-platform LMS.
Type 3: Network Protocol Driver:
Uses a middleware server to translate JDBC calls to database protocols.
How It Works: Java app → Middleware → Database, allowing database independence.
Pros:
No client-side setup; middleware handles driver logic.
Supports multiple databases via one driver.
Cons:
Requires middleware setup, adding complexity.
Slower due to network hops.
Use Case: Rare; not practical for your LMS due to setup overhead.
Type 4: Thin Driver (Most Common):
A pure Java driver that communicates directly with the database using its native protocol.
How It Works: JDBC calls are converted to database-specific network protocols (e.g., MySQL’s TCP/IP protocol).
Pros:
Fully Java-based, ensuring portability and platform independence.
High performance due to direct communication.
Easy to use; no additional setup beyond adding the driver JAR.
Cons: Database-specific (need a different driver per database).
Use Case: Ideal for your LMS (e.g., MySQL Connector/J for MySQL).

2 MARKERS
=1. Discuss the steps of setting null value in JDBC PreparedStatement
1.	Establish a Connection: First, establish a connection to the database using DriverManager.getConnection().
2.	Create a PreparedStatement: Define your SQL query with placeholders (?) for parameters.
3.	Use setNull() Method: Assign NULL to a specific parameter using setNull(int parameterIndex, int sqlType).
4.	Execute the Query: Run the query using executeUpdate() or executeQuery().
5.	Close the Resources: Always close the PreparedStatement and Connection to free up resources.

=2. Describe the use of HttpServletRequest and HttpServletResponse.
1. HttpServletRequest – Handling Client Requests
This interface is used to retrieve incoming HTTP request data from a client (browser). It provides methods to extract details such as request parameters, headers, and session attributes.
2. HttpServletResponse – Sending Responses to Clients
This interface is used to create and send responses from the server to the client. It allows setting status codes, sending data, and managing cookies.

=3. When servlet object is created?
A Servlet object is created when the servlet is first loaded and initialized by the Servlet container (e.g., Tomcat, Jetty).
•	The web container loads the servlet class.
•	It then creates an instance of the servlet class (this happens only once in the servlet's lifecycle).
•	After the instance is created, the container calls the servlet's init() method to initialize it before handling any requests

=4. Explain the working of DriverManager in JDBC
1.	Manages JDBC drivers: It keeps track of all available database drivers.
2.	Uses getConnection(): You call this method with a database URL, username, and password to request a connection.
3.	Finds the right driver: It iterates through registered drivers and selects the first one that can handle the provided database URL.
4.	Delegates connection: It tells the chosen driver to establish the actual connection to the database.
5.	Returns Connection: If successful, you get a Connection object to work with the database.

=5. Explain the use of welcome-file-list
The <welcome-file-list> element in the web.xml deployment descriptor specifies a list of files that the web server should use as default resources (welcome files) when a user accesses a directory path in a web application without specifying a particular file.
How It Works:
•	When a user visits http://example.com/app/, the server checks the <welcome-file-list> to find the default page.
•	If multiple files are listed, the server tries them in order until it finds one that exists.
•	If no welcome file is found, the server may display a directory listing or return an error.

=6. Describe the process of creating a connection object.
In JDBC (Java Database Connectivity), a Connection object is used to establish a link between a Java application and a database. It enables sending SQL commands to the database and receiving result
1.	Import JDBC Packages: Import the required classes from the java.sql package to use JDBC interfaces and classes.
2.	Load and Register JDBC Driver : Load the database-specific JDBC driver class to register it with the DriverManager. This step enables the Java application to communicate with the database.
3.	Open a Connection to Database: Use DriverManager.getConnection() with the database URL, username, and password to establish a physical connection to the database. This returns a Connection object.
4.	Create a Statement Object to Perform a Query: Create a Statement object from the Connection to send SQL commands to the database.
5.	Execute the Statement Object and Return a Query ResultSet: Execute SQL queries using the Statement object (e.g., executeQuery() for SELECT). This returns a ResultSet containing the query results.

6.	Process the ResultSet : Iterate over the ResultSet to retrieve and process the data returned by the query.
7.	Close the Connection: Close the ResultSet, Statement, and Connection objects to free resources and avoid memory leaks.
 
=7. Describe the advantages of using PreparedStatement in Java
A PreparedStatement in JDBC is a precompiled SQL statement that offers several advantages over a regular Statement object. It is used to execute parameterized queries efficiently and securely.
Prevention of SQL Injection:
•	PreparedStatement uses parameterized queries, where placeholders (?) are used instead of directly embedding user input in the SQL query. This prevents malicious SQL code (SQL injection) from being executed, enhancing security.
•	Example: Instead of concatenating user input, PreparedStatement safely binds values, ensuring the database treats them as data, not executable code.
Improved Performance for Repeated Queries:
•	The SQL query in a PreparedStatement is precompiled by the database once and cached, allowing reuse with different parameter values. This reduces compilation overhead, making it faster for repeated executions (e.g., in batch processing or loops).
•	In contrast, a Statement compiles the query each time it is executed.
Better Handling of Parameters:
•	PreparedStatement provides type-safe methods (e.g., setString(), setInt(), setDate()) to bind parameters to placeholders, reducing errors caused by incorrect data types or formatting.
•	It automatically handles special characters (e.g., quotes) in strings, simplifying query construction.
Support for Null Values:
•	PreparedStatement allows explicit setting of null values using setNull(index, sqlType), ensuring proper handling of null for different database column types (e.g., Types.VARCHAR, Types.INTEGER).
•	This is more reliable than manually handling null in a Statement.
Readability and Maintainability:
•	Queries in PreparedStatement are clearer because placeholders separate the SQL logic from parameter values, making the code easier to read and maintain.
•	This is especially useful for complex queries with multiple parameters.
Support for Batch Processing:
•	PreparedStatement supports batch execution (using addBatch() and executeBatch()), allowing multiple queries to be executed in a single database call, improving performance for bulk operations.
