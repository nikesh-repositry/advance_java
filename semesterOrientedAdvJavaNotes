        ADVANCE JAVA SEMESTER ORIENTED
UNIT-I Introduction JDBC: Introduction, JDBC Driver, DB Connectivity, Driver Manager, Connection, Statement, Result Set, Prepared 8 Hours Statement, Transaction Management, Stored Procedures. Servlet: Servlet Overview, Servlet API, Servlet Interface, Generic Servlet, HTTP Servlet, Servlet Life Cycle, Redirect requests to other resources, Session Tracking, Event and Listener.   

UNIT-II JSP JSP: Introduction, Overview, JSP Scriptlet Tag, JSP expression Tag, JSP declaration Tag, Life Cycle of JSP, JSP API, Implicit Objects: JSP request, JSP response, JSP config, JSP session, JSP Application, JSP Page Context; JSP Page, JSP Exception. 

UNIT-III Spring 5.0 Spring 5.0: Spring Core Introduction and Overview, Managing Beans, The Spring Container, The Factory Pattern, Dependency Injection (DI), Spring Managed Bean Lifecycle, Constructor Injection, Metadata/Configuration: Life Cycle Annotations, Java Configuration, XML Free configuration. 

UNIT-IV Spring MVC & Spring Boot Spring MVC: Introduction/Developing Web Application with Spring MVC, Advanced Techniques, Spring Controllers Spring Boot: Spring Boot Starters, CLI, Application Class, Logging, Auto Configuration Classes, Spring Boot dependencies, Spring data JPA introduction and Overview. 

UNIT-V JPA JPA: Introduction & overview of data persistence, Overview of ORM tools, Understanding JPA, Entities: 8 Hours Requirement for Entity Class, Persistent Fields and Properties, Primary keys in Entries, Entity Management, Querying Entities, Entities Relationships. 





UNIT 1 INTRODUCTION JDBC (java database connectivity)-----------------------------------------------------------
UNIT-I Introduction JDBC: 
Introduction, JDBC Driver, DB Connectivity, Driver Manager, Connection, Statement, Result Set, Prepared 8 Hours Statement, Transaction Management, Stored Procedures. Servlet: Servlet Overview, Servlet API, Servlet Interface, Generic Servlet, HTTP Servlet, Servlet Life Cycle, Redirect requests to other resources, Session Tracking, Event and Listener. 
introduction
definition:  :  :
jdbc(java database connectivity) is a java api that enables java applications to interact with relational database like mysql, oracle using SQL. It provides a standard interface for connecting to database, executing queries, and retrieving results, making java programs database-intependent.
JDBC components:  :  :
1. jdbc api: core interfaces and classes in the java.sql and javax.sql packages.
a.	Driver manager=manages database drivers and establishes connnecitons
b.	Connections=represents a database session
c.	Statement=executes sql queries
d.	resultSet=holds query results for processing
e.	preparedstatement=precompiled sql for secure, efficient queries.
2. jdbc drivers: database specific implementation of jdbc interfaces, provided by database vendors like connector/j
3. database: the relational database accessed via jdbc.
JDBC architecture:  :  :
1.client layer(a jdbc client is any java application or applet that connects to a server based database using jdbc api)
2.driver manager layer(the driver manager is a service of the jdbc api that manage the drivers and establishes a connection between a jdbc client and a database server.)
3.database server(a database server is a software program that provides database management functionality within a networked computing environment.)
The flow is like :
Application calls jdbc api-> the jdbc api delegates to the driver    ->driver communicates with the database, executes sql, and returns result via resultset.
[Java Application] --> [JDBC API] --> [JDBC Driver] --> [Database]
   (Your LMS code)      (java.sql)    (e.g., MySQL    (e.g., MySQL)
                                       Connector/J)
JDBC drivers:  :  :
jdbc drivers are software components that enables communication between the jdbc api and a specific database.
Four types of jdbc drivers:
Type 1: JDBC-ODBC Bridge Driver:
Uses ODBC (Open Database Connectivity) to connect to databases.
How It Works: Translates JDBC calls to ODBC, which then interacts with the database.
Pros: Works with any ODBC-compatible database.
Cons:
Requires ODBC setup on the client machine.
Poor performance due to multiple layers.
Not supported in modern Java (removed in Java 8+).
Use Case: Rarely used; not recommended for your LMS.
Type 2: Native-API Driver:
Uses database-specific native libraries (e.g., C/C++ code) to communicate.
How It Works: JDBC calls are converted to native database calls via a native library.
Pros: Faster than Type 1 due to direct native access.
Cons:
Requires native libraries, reducing portability.
Platform-dependent (e.g., Windows DLLs).
Use Case: Legacy systems; not ideal for your cross-platform LMS.
Type 3: Network Protocol Driver:
Uses a middleware server to translate JDBC calls to database protocols.
How It Works: Java app → Middleware → Database, allowing database independence.
Pros:
No client-side setup; middleware handles driver logic.
Supports multiple databases via one driver.
Cons:
Requires middleware setup, adding complexity.
Slower due to network hops.
Use Case: Rare; not practical for your LMS due to setup overhead.
Type 4: Thin Driver (Most Common):
A pure Java driver that communicates directly with the database using its native protocol.
How It Works: JDBC calls are converted to database-specific network protocols (e.g., MySQL’s TCP/IP protocol).
Pros:
Fully Java-based, ensuring portability and platform independence.
High performance due to direct communication.
Easy to use; no additional setup beyond adding the driver JAR.
Cons: Database-specific (need a different driver per database).
Use Case: Ideal for your LMS (e.g., MySQL Connector/J for MySQL).

2 MARKERS
=1. Discuss the steps of setting null value in JDBC PreparedStatement
1.	Establish a Connection: First, establish a connection to the database using DriverManager.getConnection().
2.	Create a PreparedStatement: Define your SQL query with placeholders (?) for parameters.
3.	Use setNull() Method: Assign NULL to a specific parameter using setNull(int parameterIndex, int sqlType).
4.	Execute the Query: Run the query using executeUpdate() or executeQuery().
5.	Close the Resources: Always close the PreparedStatement and Connection to free up resources.

=2. Describe the use of HttpServletRequest and HttpServletResponse.
1. HttpServletRequest – Handling Client Requests
This interface is used to retrieve incoming HTTP request data from a client (browser). It provides methods to extract details such as request parameters, headers, and session attributes.
2. HttpServletResponse – Sending Responses to Clients
This interface is used to create and send responses from the server to the client. It allows setting status codes, sending data, and managing cookies.

=3. When servlet object is created?
A Servlet object is created when the servlet is first loaded and initialized by the Servlet container (e.g., Tomcat, Jetty).
•	The web container loads the servlet class.
•	It then creates an instance of the servlet class (this happens only once in the servlet's lifecycle).
•	After the instance is created, the container calls the servlet's init() method to initialize it before handling any requests

=4. Explain the working of DriverManager in JDBC
1.	Manages JDBC drivers: It keeps track of all available database drivers.
2.	Uses getConnection(): You call this method with a database URL, username, and password to request a connection.
3.	Finds the right driver: It iterates through registered drivers and selects the first one that can handle the provided database URL.
4.	Delegates connection: It tells the chosen driver to establish the actual connection to the database.
5.	Returns Connection: If successful, you get a Connection object to work with the database.

=5. Explain the use of welcome-file-list
The <welcome-file-list> element in the web.xml deployment descriptor specifies a list of files that the web server should use as default resources (welcome files) when a user accesses a directory path in a web application without specifying a particular file.
How It Works:
•	When a user visits http://example.com/app/, the server checks the <welcome-file-list> to find the default page.
•	If multiple files are listed, the server tries them in order until it finds one that exists.
•	If no welcome file is found, the server may display a directory listing or return an error.

=6. Describe the process of creating a connection object.
In JDBC (Java Database Connectivity), a Connection object is used to establish a link between a Java application and a database. It enables sending SQL commands to the database and receiving result
1.	Import JDBC Packages: Import the required classes from the java.sql package to use JDBC interfaces and classes.
2.	Load and Register JDBC Driver : Load the database-specific JDBC driver class to register it with the DriverManager. This step enables the Java application to communicate with the database.
3.	Open a Connection to Database: Use DriverManager.getConnection() with the database URL, username, and password to establish a physical connection to the database. This returns a Connection object.
4.	Create a Statement Object to Perform a Query: Create a Statement object from the Connection to send SQL commands to the database.
5.	Execute the Statement Object and Return a Query ResultSet: Execute SQL queries using the Statement object (e.g., executeQuery() for SELECT). This returns a ResultSet containing the query results.

6.	Process the ResultSet : Iterate over the ResultSet to retrieve and process the data returned by the query.
7.	Close the Connection: Close the ResultSet, Statement, and Connection objects to free resources and avoid memory leaks.
 
=7. Describe the advantages of using PreparedStatement in Java
A PreparedStatement in JDBC is a precompiled SQL statement that offers several advantages over a regular Statement object. It is used to execute parameterized queries efficiently and securely.
Prevention of SQL Injection:
•	PreparedStatement uses parameterized queries, where placeholders (?) are used instead of directly embedding user input in the SQL query. This prevents malicious SQL code (SQL injection) from being executed, enhancing security.
•	Example: Instead of concatenating user input, PreparedStatement safely binds values, ensuring the database treats them as data, not executable code.
Improved Performance for Repeated Queries:
•	The SQL query in a PreparedStatement is precompiled by the database once and cached, allowing reuse with different parameter values. This reduces compilation overhead, making it faster for repeated executions (e.g., in batch processing or loops).
•	In contrast, a Statement compiles the query each time it is executed.
Better Handling of Parameters:
•	PreparedStatement provides type-safe methods (e.g., setString(), setInt(), setDate()) to bind parameters to placeholders, reducing errors caused by incorrect data types or formatting.
•	It automatically handles special characters (e.g., quotes) in strings, simplifying query construction.
Support for Null Values:
•	PreparedStatement allows explicit setting of null values using setNull(index, sqlType), ensuring proper handling of null for different database column types (e.g., Types.VARCHAR, Types.INTEGER).
•	This is more reliable than manually handling null in a Statement.
Readability and Maintainability:
•	Queries in PreparedStatement are clearer because placeholders separate the SQL logic from parameter values, making the code easier to read and maintain.
•	This is especially useful for complex queries with multiple parameters.
Support for Batch Processing:
•	PreparedStatement supports batch execution (using addBatch() and executeBatch()), allowing multiple queries to be executed in a single database call, improving performance for bulk operations.

=8. Discuss the concept of servlet how it gets access to its init parameters
A servlet is a Java program that runs on a web server and acts as a middle layer between client requests (usually from a web browser) and server responses. Servlets are used to create dynamic web applications, process user requests, interact with databases, and generate responses in formats like HTML, JSON, or XML. They follow a specific lifecycle managed by the servlet container, which includes loading, initialization, request handling, and destruction.
Init parameters are configuration values defined outside the servlet code that are used to initialize a servlet during startup. They help make a servlet more flexible and configurable.
Servlet init parameters are configuration values specified for a servlet in the deployment descriptor (web.xml) or via annotations. These parameters are used to provide servlet-specific configuration data, such as database connection details, file paths, or any other information needed during the servlet’s initialization
1. Defining Init Parameters in web.xml
 


2. Retrieving Init Parameters in a Servlet
The ServletConfig interface allows access to init parameters via getInitParameter().
 
3. Using Annotations (@WebServlet) for Init Parameters
Instead of web.xml, init parameters can be set using annotations.

=9. Explain the Servlet API.
The Servlet API is a set of Java interfaces and classes that allow developers to build server-side web components (called servlets) which handle HTTP requests and generate responses. This API is part of the Java EE (Jakarta EE) platform and is provided by the javax.servlet and javax.servlet.http packages (or jakarta.servlet in newer versions).
Purpose of the Servlet API
•	To enable Java applications to communicate with web clients (browsers).
•	To allow dynamic generation of HTML, JSON, XML, etc., based on client requests.
•	To handle complex web-based business logic on the server side.
javax.servlet package:
Contains core interfaces and classes like Servlet, ServletRequest, ServletResponse, and ServletConfig that define the contract between the servlet and the servlet container.

javax.servlet.http package:
Provides HTTP-specific classes and interfaces such as HttpServlet, HttpServletRequest, and HttpServletResponse for handling HTTP protocol requests and responses.

Servlet Lifecycle (as defined by the API)
1.Loading and Instantiation:
The servlet container loads the servlet class and creates an instance.

2.Initialization (init()):
The container calls the init() method once to initialize the servlet.

3.Request Handling (service()):
For each client request, the container calls the service() method, which processes requests and generates responses. For HTTP servlets, this is usually delegated to methods like doGet() or doPost().

4.Destruction (destroy()):
When the servlet is taken out of service, the destroy() method is called to release resources.

Request and Response Handling
ServletRequest & ServletResponse:
These interfaces provide methods to read client data (parameters, headers, input streams) and write responses (content type, output streams).

HttpServletRequest & HttpServletResponse:
Extend the above interfaces to provide HTTP-specific functionality, such as handling sessions, cookies, and HTTP methods (GET, POST, etc.)
 

=10. Describe various JDBC statements?
The Statement interface is the most basic form of executing SQL statements in JDBC. It is used for sending simple, static SQL queries to the database, such as table creation or deletion, or queries that do not require input parameters. When a Statement object is created using the createStatement() method of a Connection object, it can execute SQL commands using methods like executeQuery() for SELECT statements and executeUpdate() for INSERT, UPDATE, or DELETE operations. However, each time a query is executed, the SQL statement is sent to the database and compiled, which can be inefficient for repeated queries. Additionally, since the SQL is constructed as a plain string, this approach is vulnerable to SQL injection attacks if user input is concatenated directly into the query.
 
To address these limitations, JDBC provides the PreparedStatement interface, which is used for executing precompiled SQL statements with or without parameters. PreparedStatements are created using the prepareStatement() method of the Connection object, where the SQL query can include placeholders (?) for parameters. These parameters are set using setter methods like setInt(), setString(), etc. The main advantage of PreparedStatement is that the SQL statement is compiled only once and can be executed multiple times with different parameter values, leading to better performance. Moreover, PreparedStatement automatically escapes parameter values, making it much safer against SQL injection attacks. This makes it the preferred choice for executing dynamic queries, especially those involving user input or repeated execution.
 
The third type, CallableStatement, is designed for executing stored procedures in the database. Stored procedures are pre-written SQL routines stored in the database, often used to encapsulate complex business logic or batch operations. CallableStatement objects are created using the prepareCall() method of the Connection object, and the SQL syntax typically uses curly braces to indicate a procedure call (e.g., {call procedureName(?, ?)}). CallableStatement supports input, output, and input-output parameters, which can be set and retrieved using methods like setInt(), registerOutParameter(), and getInt(). This makes CallableStatement ideal for interacting with advanced database features, such as retrieving computed values or handling multiple result sets.

=11. Explain ResultSet. Discuss all the types of ResultSet with example.
A ResultSet is a Java interface in the java.sql package that represents the result of an SQL SELECT query executed against a database. It provides methods to retrieve and manipulate data from the database in a tabular format, where each row represents a record and each column represents a field. The ResultSet maintains a cursor pointing to the current row of data, which can be navigated using methods like next(), previous(), or absolute(). It is typically obtained by executing a query using a Statement or PreparedStatement.
There are three different characteristics by which ResultSet types are differentiated

1.Scrollability: Determines whether you can move back and forth in the ResultSet
TYPE_FORWARD_ONLY: Can only move forward through the rows
TYPE_SCROLL_INSENSITIVE: Can move forward and backward but changes are not reflect ResultSet
TYPE_SCROLL_SENSITIVE: Can move forward and backward but changes are affect the ResultSet
	
2.Concurrency: Determines whether you can update the ResultSet
CONCUR_READ_ONLY: Can only read data
CONCUR_UPDATABLE: Allows updates to the ResultSet
Holdability: Determines what happens to the ResultSet when a 

3.Transaction is committed.
HOLD_CURSORS_OVER_COMMIT: The ResultSet remains open after a commit
CLOSE_CURSORS_AT_COMMIT: The ResultSet closes after a commit
TYPE_FORWARD_ONLY (Default):
Description: The cursor can only move forward through the result set (using next()). It is the default type and is optimized for simple, read-only queries.
Characteristics:
•	Fastest and least resource-intensive.
•	Cannot move backward or jump to specific rows.
•	Typically read-only (unless explicitly set to updatable).
Use Case: Suitable for one-time sequential processing of query results.
 
TYPE_SCROLL_INSENSITIVE:
Description: The cursor can move forward (next()), backward (previous()), or to specific rows (absolute(), relative()). Changes made to the underlying database after the ResultSet is created are not reflected.
Characteristics:
•	Scrollable in both directions.
•	Insensitive to database updates (static snapshot of data).
•	Read-only or updatable based on concurrency setting.
Use Case: Useful for applications requiring navigation through results without reflecting concurrent database changes.
 
TYPE_SCROLL_SENSITIVE:
Description: Similar to TYPE_SCROLL_INSENSITIVE, but the ResultSet reflects changes (e.g., updates, deletes) made to the underlying database while the result set is open, depending on the database’s support.
Characteristics:
•	Scrollable in both directions.
•	Sensitive to database changes (if supported by the database).
•	More resource-intensive due to dynamic updates.
Use Case: Suitable for applications needing real-time updates to the result set, such as interactive data grids.
 

