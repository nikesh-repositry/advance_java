        ADVANCE JAVA SEMESTER ORIENTED
UNIT-I Introduction JDBC: Introduction, JDBC Driver, DB Connectivity, Driver Manager, Connection, Statement, Result Set, Prepared 8 Hours Statement, Transaction Management, Stored Procedures. Servlet: Servlet Overview, Servlet API, Servlet Interface, Generic Servlet, HTTP Servlet, Servlet Life Cycle, Redirect requests to other resources, Session Tracking, Event and Listener.   

UNIT-II JSP JSP: Introduction, Overview, JSP Scriptlet Tag, JSP expression Tag, JSP declaration Tag, Life Cycle of JSP, JSP API, Implicit Objects: JSP request, JSP response, JSP config, JSP session, JSP Application, JSP Page Context; JSP Page, JSP Exception. 

UNIT-III Spring 5.0 Spring 5.0: Spring Core Introduction and Overview, Managing Beans, The Spring Container, The Factory Pattern, Dependency Injection (DI), Spring Managed Bean Lifecycle, Constructor Injection, Metadata/Configuration: Life Cycle Annotations, Java Configuration, XML Free configuration. 

UNIT-IV Spring MVC & Spring Boot Spring MVC: Introduction/Developing Web Application with Spring MVC, Advanced Techniques, Spring Controllers Spring Boot: Spring Boot Starters, CLI, Application Class, Logging, Auto Configuration Classes, Spring Boot dependencies, Spring data JPA introduction and Overview. 

UNIT-V JPA JPA: Introduction & overview of data persistence, Overview of ORM tools, Understanding JPA, Entities: 8 Hours Requirement for Entity Class, Persistent Fields and Properties, Primary keys in Entries, Entity Management, Querying Entities, Entities Relationships. 





UNIT 1 INTRODUCTION JDBC (java database connectivity)-----------------------------------------------------------
UNIT-I Introduction JDBC: 
Introduction, JDBC Driver, DB Connectivity, Driver Manager, Connection, Statement, Result Set, Prepared 8 Hours Statement, Transaction Management, Stored Procedures. Servlet: Servlet Overview, Servlet API, Servlet Interface, Generic Servlet, HTTP Servlet, Servlet Life Cycle, Redirect requests to other resources, Session Tracking, Event and Listener. 
introduction
definition:  :  :
jdbc(java database connectivity) is a java api that enables java applications to interact with relational database like mysql, oracle using SQL. It provides a standard interface for connecting to database, executing queries, and retrieving results, making java programs database-intependent.
JDBC components:  :  :
1. jdbc api: core interfaces and classes in the java.sql and javax.sql packages.
a.	Driver manager=manages database drivers and establishes connnecitons
b.	Connections=represents a database session
c.	Statement=executes sql queries
d.	resultSet=holds query results for processing
e.	preparedstatement=precompiled sql for secure, efficient queries.
2. jdbc drivers: database specific implementation of jdbc interfaces, provided by database vendors like connector/j
3. database: the relational database accessed via jdbc.
JDBC architecture:  :  :
1.client layer(a jdbc client is any java application or applet that connects to a server based database using jdbc api)
2.driver manager layer(the driver manager is a service of the jdbc api that manage the drivers and establishes a connection between a jdbc client and a database server.)
3.database server(a database server is a software program that provides database management functionality within a networked computing environment.)
The flow is like :
Application calls jdbc api-> the jdbc api delegates to the driver    ->driver communicates with the database, executes sql, and returns result via resultset.
[Java Application] --> [JDBC API] --> [JDBC Driver] --> [Database]
   (Your LMS code)      (java.sql)    (e.g., MySQL    (e.g., MySQL)
                                       Connector/J)
JDBC drivers:  :  :
jdbc drivers are software components that enables communication between the jdbc api and a specific database.
Four types of jdbc drivers:
Type 1: JDBC-ODBC Bridge Driver:
Uses ODBC (Open Database Connectivity) to connect to databases.
How It Works: Translates JDBC calls to ODBC, which then interacts with the database.
Pros: Works with any ODBC-compatible database.
Cons:
Requires ODBC setup on the client machine.
Poor performance due to multiple layers.
Not supported in modern Java (removed in Java 8+).
Use Case: Rarely used; not recommended for your LMS.
Type 2: Native-API Driver:
Uses database-specific native libraries (e.g., C/C++ code) to communicate.
How It Works: JDBC calls are converted to native database calls via a native library.
Pros: Faster than Type 1 due to direct native access.
Cons:
Requires native libraries, reducing portability.
Platform-dependent (e.g., Windows DLLs).
Use Case: Legacy systems; not ideal for your cross-platform LMS.
Type 3: Network Protocol Driver:
Uses a middleware server to translate JDBC calls to database protocols.
How It Works: Java app → Middleware → Database, allowing database independence.
Pros:
No client-side setup; middleware handles driver logic.
Supports multiple databases via one driver.
Cons:
Requires middleware setup, adding complexity.
Slower due to network hops.
Use Case: Rare; not practical for your LMS due to setup overhead.
Type 4: Thin Driver (Most Common):
A pure Java driver that communicates directly with the database using its native protocol.
How It Works: JDBC calls are converted to database-specific network protocols (e.g., MySQL’s TCP/IP protocol).
Pros:
Fully Java-based, ensuring portability and platform independence.
High performance due to direct communication.
Easy to use; no additional setup beyond adding the driver JAR.
Cons: Database-specific (need a different driver per database).
Use Case: Ideal for your LMS (e.g., MySQL Connector/J for MySQL).

2 MARKERS
=1. Discuss the steps of setting null value in JDBC PreparedStatement
1.	Establish a Connection: First, establish a connection to the database using DriverManager.getConnection().
2.	Create a PreparedStatement: Define your SQL query with placeholders (?) for parameters.
3.	Use setNull() Method: Assign NULL to a specific parameter using setNull(int parameterIndex, int sqlType).
4.	Execute the Query: Run the query using executeUpdate() or executeQuery().
5.	Close the Resources: Always close the PreparedStatement and Connection to free up resources.

=2. Describe the use of HttpServletRequest and HttpServletResponse.
1. HttpServletRequest – Handling Client Requests
This interface is used to retrieve incoming HTTP request data from a client (browser). It provides methods to extract details such as request parameters, headers, and session attributes.
2. HttpServletResponse – Sending Responses to Clients
This interface is used to create and send responses from the server to the client. It allows setting status codes, sending data, and managing cookies.

=3. When servlet object is created?
A Servlet object is created when the servlet is first loaded and initialized by the Servlet container (e.g., Tomcat, Jetty).
•	The web container loads the servlet class.
•	It then creates an instance of the servlet class (this happens only once in the servlet's lifecycle).
•	After the instance is created, the container calls the servlet's init() method to initialize it before handling any requests

=4. Explain the working of DriverManager in JDBC
1.	Manages JDBC drivers: It keeps track of all available database drivers.
2.	Uses getConnection(): You call this method with a database URL, username, and password to request a connection.
3.	Finds the right driver: It iterates through registered drivers and selects the first one that can handle the provided database URL.
4.	Delegates connection: It tells the chosen driver to establish the actual connection to the database.
5.	Returns Connection: If successful, you get a Connection object to work with the database.

=5. Explain the use of welcome-file-list
The <welcome-file-list> element in the web.xml deployment descriptor specifies a list of files that the web server should use as default resources (welcome files) when a user accesses a directory path in a web application without specifying a particular file.
How It Works:
•	When a user visits http://example.com/app/, the server checks the <welcome-file-list> to find the default page.
•	If multiple files are listed, the server tries them in order until it finds one that exists.
•	If no welcome file is found, the server may display a directory listing or return an error.

=6. Describe the process of creating a connection object.
In JDBC (Java Database Connectivity), a Connection object is used to establish a link between a Java application and a database. It enables sending SQL commands to the database and receiving result
1.	Import JDBC Packages: Import the required classes from the java.sql package to use JDBC interfaces and classes.
2.	Load and Register JDBC Driver : Load the database-specific JDBC driver class to register it with the DriverManager. This step enables the Java application to communicate with the database.
3.	Open a Connection to Database: Use DriverManager.getConnection() with the database URL, username, and password to establish a physical connection to the database. This returns a Connection object.
4.	Create a Statement Object to Perform a Query: Create a Statement object from the Connection to send SQL commands to the database.
5.	Execute the Statement Object and Return a Query ResultSet: Execute SQL queries using the Statement object (e.g., executeQuery() for SELECT). This returns a ResultSet containing the query results.

6.	Process the ResultSet : Iterate over the ResultSet to retrieve and process the data returned by the query.
7.	Close the Connection: Close the ResultSet, Statement, and Connection objects to free resources and avoid memory leaks.
 
=7. Describe the advantages of using PreparedStatement in Java
A PreparedStatement in JDBC is a precompiled SQL statement that offers several advantages over a regular Statement object. It is used to execute parameterized queries efficiently and securely.
Prevention of SQL Injection:
•	PreparedStatement uses parameterized queries, where placeholders (?) are used instead of directly embedding user input in the SQL query. This prevents malicious SQL code (SQL injection) from being executed, enhancing security.
•	Example: Instead of concatenating user input, PreparedStatement safely binds values, ensuring the database treats them as data, not executable code.
Improved Performance for Repeated Queries:
•	The SQL query in a PreparedStatement is precompiled by the database once and cached, allowing reuse with different parameter values. This reduces compilation overhead, making it faster for repeated executions (e.g., in batch processing or loops).
•	In contrast, a Statement compiles the query each time it is executed.
Better Handling of Parameters:
•	PreparedStatement provides type-safe methods (e.g., setString(), setInt(), setDate()) to bind parameters to placeholders, reducing errors caused by incorrect data types or formatting.
•	It automatically handles special characters (e.g., quotes) in strings, simplifying query construction.
Support for Null Values:
•	PreparedStatement allows explicit setting of null values using setNull(index, sqlType), ensuring proper handling of null for different database column types (e.g., Types.VARCHAR, Types.INTEGER).
•	This is more reliable than manually handling null in a Statement.
Readability and Maintainability:
•	Queries in PreparedStatement are clearer because placeholders separate the SQL logic from parameter values, making the code easier to read and maintain.
•	This is especially useful for complex queries with multiple parameters.
Support for Batch Processing:
•	PreparedStatement supports batch execution (using addBatch() and executeBatch()), allowing multiple queries to be executed in a single database call, improving performance for bulk operations.

=8. Discuss the concept of servlet how it gets access to its init parameters
A servlet is a Java program that runs on a web server and acts as a middle layer between client requests (usually from a web browser) and server responses. Servlets are used to create dynamic web applications, process user requests, interact with databases, and generate responses in formats like HTML, JSON, or XML. They follow a specific lifecycle managed by the servlet container, which includes loading, initialization, request handling, and destruction.
Init parameters are configuration values defined outside the servlet code that are used to initialize a servlet during startup. They help make a servlet more flexible and configurable.
Servlet init parameters are configuration values specified for a servlet in the deployment descriptor (web.xml) or via annotations. These parameters are used to provide servlet-specific configuration data, such as database connection details, file paths, or any other information needed during the servlet’s initialization
1. Defining Init Parameters in web.xml
 


2. Retrieving Init Parameters in a Servlet
The ServletConfig interface allows access to init parameters via getInitParameter().
 
3. Using Annotations (@WebServlet) for Init Parameters
Instead of web.xml, init parameters can be set using annotations.

=9. Explain the Servlet API.
The Servlet API is a set of Java interfaces and classes that allow developers to build server-side web components (called servlets) which handle HTTP requests and generate responses. This API is part of the Java EE (Jakarta EE) platform and is provided by the javax.servlet and javax.servlet.http packages (or jakarta.servlet in newer versions).
Purpose of the Servlet API
•	To enable Java applications to communicate with web clients (browsers).
•	To allow dynamic generation of HTML, JSON, XML, etc., based on client requests.
•	To handle complex web-based business logic on the server side.
javax.servlet package:
Contains core interfaces and classes like Servlet, ServletRequest, ServletResponse, and ServletConfig that define the contract between the servlet and the servlet container.

javax.servlet.http package:
Provides HTTP-specific classes and interfaces such as HttpServlet, HttpServletRequest, and HttpServletResponse for handling HTTP protocol requests and responses.

Servlet Lifecycle (as defined by the API)
1.Loading and Instantiation:
The servlet container loads the servlet class and creates an instance.

2.Initialization (init()):
The container calls the init() method once to initialize the servlet.

3.Request Handling (service()):
For each client request, the container calls the service() method, which processes requests and generates responses. For HTTP servlets, this is usually delegated to methods like doGet() or doPost().

4.Destruction (destroy()):
When the servlet is taken out of service, the destroy() method is called to release resources.

Request and Response Handling
ServletRequest & ServletResponse:
These interfaces provide methods to read client data (parameters, headers, input streams) and write responses (content type, output streams).

HttpServletRequest & HttpServletResponse:
Extend the above interfaces to provide HTTP-specific functionality, such as handling sessions, cookies, and HTTP methods (GET, POST, etc.)
 

=10. Describe various JDBC statements?
The Statement interface is the most basic form of executing SQL statements in JDBC. It is used for sending simple, static SQL queries to the database, such as table creation or deletion, or queries that do not require input parameters. When a Statement object is created using the createStatement() method of a Connection object, it can execute SQL commands using methods like executeQuery() for SELECT statements and executeUpdate() for INSERT, UPDATE, or DELETE operations. However, each time a query is executed, the SQL statement is sent to the database and compiled, which can be inefficient for repeated queries. Additionally, since the SQL is constructed as a plain string, this approach is vulnerable to SQL injection attacks if user input is concatenated directly into the query.
 
To address these limitations, JDBC provides the PreparedStatement interface, which is used for executing precompiled SQL statements with or without parameters. PreparedStatements are created using the prepareStatement() method of the Connection object, where the SQL query can include placeholders (?) for parameters. These parameters are set using setter methods like setInt(), setString(), etc. The main advantage of PreparedStatement is that the SQL statement is compiled only once and can be executed multiple times with different parameter values, leading to better performance. Moreover, PreparedStatement automatically escapes parameter values, making it much safer against SQL injection attacks. This makes it the preferred choice for executing dynamic queries, especially those involving user input or repeated execution.
 
The third type, CallableStatement, is designed for executing stored procedures in the database. Stored procedures are pre-written SQL routines stored in the database, often used to encapsulate complex business logic or batch operations. CallableStatement objects are created using the prepareCall() method of the Connection object, and the SQL syntax typically uses curly braces to indicate a procedure call (e.g., {call procedureName(?, ?)}). CallableStatement supports input, output, and input-output parameters, which can be set and retrieved using methods like setInt(), registerOutParameter(), and getInt(). This makes CallableStatement ideal for interacting with advanced database features, such as retrieving computed values or handling multiple result sets.

=11. Explain ResultSet. Discuss all the types of ResultSet with example.
A ResultSet is a Java interface in the java.sql package that represents the result of an SQL SELECT query executed against a database. It provides methods to retrieve and manipulate data from the database in a tabular format, where each row represents a record and each column represents a field. The ResultSet maintains a cursor pointing to the current row of data, which can be navigated using methods like next(), previous(), or absolute(). It is typically obtained by executing a query using a Statement or PreparedStatement.
There are three different characteristics by which ResultSet types are differentiated

1.Scrollability: Determines whether you can move back and forth in the ResultSet
TYPE_FORWARD_ONLY: Can only move forward through the rows
TYPE_SCROLL_INSENSITIVE: Can move forward and backward but changes are not reflect ResultSet
TYPE_SCROLL_SENSITIVE: Can move forward and backward but changes are affect the ResultSet
	
2.Concurrency: Determines whether you can update the ResultSet
CONCUR_READ_ONLY: Can only read data
CONCUR_UPDATABLE: Allows updates to the ResultSet
Holdability: Determines what happens to the ResultSet when a 

3.Transaction is committed.
HOLD_CURSORS_OVER_COMMIT: The ResultSet remains open after a commit
CLOSE_CURSORS_AT_COMMIT: The ResultSet closes after a commit
TYPE_FORWARD_ONLY (Default):
Description: The cursor can only move forward through the result set (using next()). It is the default type and is optimized for simple, read-only queries.
Characteristics:
•	Fastest and least resource-intensive.
•	Cannot move backward or jump to specific rows.
•	Typically read-only (unless explicitly set to updatable).
Use Case: Suitable for one-time sequential processing of query results.
 
TYPE_SCROLL_INSENSITIVE:
Description: The cursor can move forward (next()), backward (previous()), or to specific rows (absolute(), relative()). Changes made to the underlying database after the ResultSet is created are not reflected.
Characteristics:
•	Scrollable in both directions.
•	Insensitive to database updates (static snapshot of data).
•	Read-only or updatable based on concurrency setting.
Use Case: Useful for applications requiring navigation through results without reflecting concurrent database changes.
 
TYPE_SCROLL_SENSITIVE:
Description: Similar to TYPE_SCROLL_INSENSITIVE, but the ResultSet reflects changes (e.g., updates, deletes) made to the underlying database while the result set is open, depending on the database’s support.
Characteristics:
•	Scrollable in both directions.
•	Sensitive to database changes (if supported by the database).
•	More resource-intensive due to dynamic updates.
Use Case: Suitable for applications needing real-time updates to the result set, such as interactive data grids.
 
=12. List advantages and disadvantages of Servlets
Advantages of Servlets
•	High Performance: Servlets are faster than traditional CGI scripts because they use threads to handle multiple requests within a single process, avoiding the overhead of creating a new process for each request.
•	Platform Independence: Servlets are written in Java, making them portable across different operating systems and web servers that support Java.
•	Robustness and Security: Servlets inherit Java’s features such as exception handling, garbage collection, memory management, and built-in security, making them reliable and safe for web development.
•	Scalability: Servlets can efficiently handle multiple, simultaneous client requests using multi-threading, making them suitable for large-scale web applications.
•	Reusability and Modularity: Servlets promote code reusability and modularity, as they can be easily managed, updated, and reused across different applications.
•	Easy Integration: Servlets can communicate with other servlets, JavaBeans, databases, and external applications, enabling strong integration with enterprise systems.
•	Session Management: Servlets provide their own API for maintaining sessions, which is essential for web applications that require user tracking.
•	Efficient Resource Management: Only one instance of a servlet is loaded into memory, with each client request handled by a separate thread, reducing memory usage and improving management of persistent data.

Disadvantages of Servlets
•	Complexity in Design: Writing and designing servlets can be complex, especially when mixing HTML with Java code, making the code bulky and harder to maintain.
•	Difficult to Modify: Any change in the servlet code requires recompiling, reloading, and restarting the servlet container, which can be time-consuming.
•	Challenging for Beginners: Servlets require a good understanding of Java and web technologies, making them less suitable for novice programmers.
•	Separation of Concerns: Mixing business logic with presentation (HTML) in servlets can lead to less maintainable code compared to technologies like JSP, which separate logic from presentation.
•	Environment Dependency: Servlets require a Java Runtime Environment (JRE) on the server, which may not be available or desired in all hosting environments.
•	State Management Overhead: Managing state (sessions, cookies) in servlets can add complexity, as HTTP is a stateless protocol and developers must handle session management explicitly.

=13. Describe all the life-cycle methods for a servlet
The life-cycle of a servlet is managed by the servlet container and consists of several well-defined phases, each associated with specific methods. These methods ensure the servlet is properly initialized, can handle client requests, and is eventually cleaned up before removal. The main life-cycle methods are init(), service(), and destroy()
1. init() Method
Purpose: The init() method is called once when the servlet is first loaded into memory by the servlet container, either at server startup or when the servlet is accessed for the first time.
Function: It is used for initialization tasks, such as setting up database connections, reading configuration parameters, or allocating resources needed during the servlet’s operation.
Characteristics: This method is called only once in the servlet’s life-cycle and is guaranteed to complete before any requests are handled.

2. service() Method
Purpose: The service() method is invoked by the servlet container for every client request directed to the servlet.
Function: It receives ServletRequest and ServletResponse objects, processes the request, and generates a response. In generic servlets, you override service() directly, but in HTTP servlets, the service() method dispatches requests to specific methods like doGet(), doPost(), doPut(), etc., based on the HTTP request type.
Characteristics: This method can be called multiple times—once for each request—throughout the servlet’s life.

3. destroy() Method
Purpose: The destroy() method is called once just before the servlet is removed from service (such as during server shutdown or servlet reloading).
Function: It is used for cleanup activities, such as closing database connections, releasing resources, or saving state.
Characteristics: Like init(), this method is called only once in the servlet’s life-cycle

=14. Explain the Servlet Architecture
 
1. Client
The client shown in the architecture above is the web browser and it primarily works as a medium that sends out HTTP requests over to the web server and the web server generates a response based on some processing in the servlet and the client further processes the response.

2. Web Server
Primary job of a web server is to process the requests and responses that a user sends over time and maintain how a web user would be able to access the files that has been hosted over the server. The server we are talking about here is a software which manages access to a centralized resource or service in a network. There are precisely two types of webservers:

•	Static web server
•	Dynamic web server

3. Web Container
Web container is another typical component in servlet architecture which is responsible for communicating with the servlets. Two prime tasks of a web container are:
•	Managing the servlet lifecycle
•	URL mapping
Web container sits at the server-side managing and handling all the requests that are coming in either from the servlets or from some JSP pages or potentially any other file system.
How does a Servlet Request flow?
Every servlet should override the following 3 methods namely:
•	init(): To initalize/instantiate the servlet container.
•	service(): This method acts like an intermediatory between the HTTP request and the business logic to serve that particular request.
•	destroy(): This method is used to deallocate the memory allocated to the servlet.
These methods are used to process the request from the user.
Following are the steps in which a request flows through a servlet which can be observed in the architecture diagram:
•	The client sends over a request.
•	The request is accepted by the web server and forwarded to the web container.
•	In order to obtain the servlet's address, the web container traces web.xml file corresponding to the request URL pattern.
•	By the time above process takes place, the servlet should have been instantiated and initialized. The init() method is invoked to initialize the servlet.
•	By passing ServletRequest and Response object, public service() method is called by the container.
•	In the next step, the ServletRequest and ServletResponse objects are type casted to HttpServletRequest and HttpServletResponse objects by the public service() method.
•	Now protected service() method is called by the public service() method.
•	The protected service() method dispatches the request to the correct handler method based on the type of request.
When servlet container shuts down, it unloads all the servlets and calls destroy() method for each initialized servlet.


                                               10 MARKERS


=15. Explain the method of calling one Servlet from another Servlet. Explain using  example.
In a Java web application, a servlet can call another servlet to delegate tasks, share processing logic, or forward requests. This is typically achieved using request dispatching or redirecting. The two primary methods provided by the Servlet API are:
	
1.RequestDispatcher.forward():
Description: Forwards the current request and response to another servlet (or resource, e.g., JSP) within the same web application. The client is unaware of the forwarding, as it happens server-side, and the original servlet’s response is discarded.
Characteristics:
•	Retains the original request URL in the client’s browser.
•	Shares the same HttpServletRequest and HttpServletResponse objects.
•	Suitable for internal processing where the second servlet completes the response.
Use Case: When one servlet processes initial data and hands off to another for final output (e.g., a controller servlet forwarding to a view servlet).

HttpServletResponse.sendRedirect():
Description: Sends a redirect response to the client, instructing the browser to make a new request to the specified servlet (or URL). This is a client-side operation, resulting in a new HTTP request.
Characteristics:
•	Changes the URL in the client’s browser.
•	Creates a new HttpServletRequest and HttpServletResponse for the target servlet.
•	Can redirect to resources within or outside the web application.
Use Case: When the client needs to be redirected to a different page or servlet (e.g., after form submission to a success page).






FirstServlet: Calls the second servlet.
SecondServlet: Processes the request forwarded by the first servlet.
Firstservlet.java
 
Secondservlet.java

=16. Describe the Servlet Class Hierarchy with proper diagram
 
🔷 1. java.lang.Object
At the top of the hierarchy lies the Object class, which is the parent of all Java classes. It provides basic methods such as toString(), equals(), and hashCode() that are inherited by every class in Java, including servlets. While this class doesn't contribute directly to servlet functionalities, it is fundamental because it ensures that servlet classes inherit core Java capabilities.

🔷 2. javax.servlet.Servlet (Interface)
The Servlet interface is the foundation of the servlet API, defining the lifecycle of a servlet. It declares five essential methods: init(), service(), destroy(), getServletConfig(), and getServletInfo(). Every servlet must implement this interface either directly or indirectly. These methods allow a servlet to be initialized, handle client requests, provide information, and be destroyed by the container. Thus, this interface establishes the core structure every servlet must follow.

🔷 3. javax.servlet.GenericServlet (Abstract Class)
The GenericServlet class is an abstract implementation of the Servlet interface. It provides default implementations of most methods in the Servlet interface, except the service() method, which must be defined by subclasses. It also adds convenience methods like getServletContext() and getInitParameter() to access configuration and context information. This class is protocol-independent, meaning it can be used for non-HTTP servlets, though in practice, it is mostly extended through its subclass HttpServlet.

🔷 4. javax.servlet.http.HttpServlet (Concrete Class)
The HttpServlet class extends GenericServlet and is a fully implemented class designed for handling HTTP requests. It simplifies servlet development by providing methods corresponding to HTTP verbs such as doGet(), doPost(), doPut(), doDelete(), etc. Developers only need to override these methods to define how their servlet should respond to different types of HTTP requests. It is the most commonly used class in servlet development as most web applications communicate over the HTTP protocol.

🔷 5. User-Defined Servlet Class
At the final level, the developer creates a custom servlet class by extending the HttpServlet class. In this class, specific logic is written by overriding methods like doGet() and doPost() to generate dynamic responses based on client requests. This level represents the actual working servlet in a web application. By relying on the classes and interfaces above it, the user-defined servlet benefits from standardized request handling and a managed lifecycle.

 
=17. Build a program that provide the GenericServlet class and its method implementation
The GenericServlet class is an abstract class in the Servlet API that provides basic servlet functionality. It is protocol-independent, meaning it can be used for any type of request, not just HTTP.GenericServlet is an abstract class in the Java Servlet API, defined in the javax.servlet package. It simplifies the process of writing servlets by providing basic implementations for most of the methods in the Servlet and ServletConfig interfaces, except for the service() method, which remains abstract and must be implemented by subclasses
To create a servlet using GenericServlet, you extend the class and implement the service() method. This method receives ServletRequest and ServletResponse objects, which you use to process the request and generate a response.


